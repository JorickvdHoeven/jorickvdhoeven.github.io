[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "blog",
    "section": "",
    "text": "Creating anonymized pseudo-random IDs in T-SQL\n\n\n\n\n\n\n\nsnippet\n\n\nT-SQL\n\n\n\n\n\n\n\n\n\n\n\nJan 31, 2017\n\n\nJorick van der Hoeven\n\n\n\n\n\n\n  \n\n\n\n\nDistinct values in all columns in T-SQL\n\n\n\n\n\n\n\nsnippet\n\n\nT-SQL\n\n\n\n\n\n\n\n\n\n\n\nJan 31, 2017\n\n\nJorick van der Hoeven\n\n\n\n\n\n\n  \n\n\n\n\nPivoting tables when you don’t know the columns in T-SQL\n\n\n\n\n\n\n\nsnippet\n\n\nT-SQL\n\n\n\n\n\n\n\n\n\n\n\n\nJun 11, 2014\n\n\nJorick van der Hoeven\n\n\n\n\n\n\n  \n\n\n\n\nFirst or last in T-SQL\n\n\n\n\n\n\n\nsnippet\n\n\nT-SQL\n\n\n\n\n\n\n\n\n\n\n\nDec 10, 2012\n\n\nJorick van der Hoeven\n\n\n\n\n\n\n  \n\n\n\n\nCombining strings in T-SQL\n\n\n\n\n\n\n\nsnippet\n\n\nT-SQL\n\n\n\n\n\n\n\n\n\n\n\nOct 22, 2012\n\n\nJorick van der Hoeven\n\n\n\n\n\n\n  \n\n\n\n\nSearching for hidden characters in Excel\n\n\n\n\n\n\n\nsnippet\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2012\n\n\nJorick van der Hoeven\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-1/introduction-to-SIR-models-1.html",
    "href": "notebooks/coffee course/introduction-to-SIR-models-1/introduction-to-SIR-models-1.html",
    "title": "Python Coffee Courses 103 - Basic SIR modeling and how to visualize it",
    "section": "",
    "text": "Import the libraries we will need to execute on the calculations and modelling today.\nimport pandas as pd  # Loading the NYC dataset \nimport numpy as np   # performing fast calculations to build our simulation\nimport plotly.express as px # Quick visuals for data exploration\nfrom ipywidgets import widgets # sliders, buttons and visual layout of the dashboard\nimport plotly.graph_objects as go # plotly objects to place on our graph\nimport math # python mathematical functions"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-1/introduction-to-SIR-models-1.html#susceptible-to-infectious",
    "href": "notebooks/coffee course/introduction-to-SIR-models-1/introduction-to-SIR-models-1.html#susceptible-to-infectious",
    "title": "Python Coffee Courses 103 - Basic SIR modeling and how to visualize it",
    "section": "Susceptible to Infectious",
    "text": "Susceptible to Infectious\nFor Susceptible to Infectious, we’re going to multiply the infectious rate by the number of people who have been infected and by the ratio of people still susceptible.\n$ \\[\\begin{align}\n\\large\n\\mathit{daily\\_infected} = \\mathit{  infection\\_rate} * \\mathit{previous\\_day\\_infected} * \\frac{\\mathit{previous\\_day\\_susceptible}}{\\mathit{population}}\n\\end{align}\\] $\nwritten in python as:\ndaily_infected = (infection_rate * y_infected[day-1] * (y_susceptible[day-1])/population)"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-1/introduction-to-SIR-models-1.html#infectious-to-removed",
    "href": "notebooks/coffee course/introduction-to-SIR-models-1/introduction-to-SIR-models-1.html#infectious-to-removed",
    "title": "Python Coffee Courses 103 - Basic SIR modeling and how to visualize it",
    "section": "Infectious to Removed",
    "text": "Infectious to Removed\nTo move people from the infectious category to the removed category we’re going to multiply the number of infectious people on the day before by the removal rate.\n$ \\[\\begin{align}\n\\large\n\\mathit{daily\\_removed} = \\mathit{removal\\_rate} * \\mathit{previous\\_day\\_infected}\n\\end{align}\\] $\nwritten in python as:\ndaily_removed = removal_rate * y_infected[day-1]\nWith the figures for the number of people who have moved from Susceptible to Infectious and have moved from Infectious to Removed calculated, we can substract them from the previous day values to get our new Susceptible, Infectious, Removed numbers.\nWritten out in python it looks like the code written below:\n\nfor day in x_days[1:days-1]:\n    \n        # convert our day value to integer because numpy works with floating point\n        # values by default instead of integers.\n        day = int(day)\n\n        # Calculate the number of people to move from one category to another category\n        # as described above.\n        daily_infected = (infection_rate * y_infected[day-1] * (y_susceptible[day-1])/population)\n        daily_removed = removal_rate * y_infected[day-1]\n\n        # Add and remove the calculated amounts from each category for thie calculated day\n        y_susceptible.append( max(y_susceptible[day-1] - daily_infected, 0) )\n        y_infected.append(        y_infected[day-1]    + daily_infected - daily_removed )\n        y_removed.append(         y_removed[day-1]     + daily_removed )\n        \n\nWe now have the data we need to build our visualization and show how the different groups of people interact with each other.\n\n\n# This figure builder allows us to create an interactive figure to which \n# we are going to add the data we calculated one by one\nfig = go.FigureWidget() \n\n# This visualization only looks good if the bars are stacked, so we're going to\n# set the stacking option here so that the new series added to the graph will \n# stack.\nfig.update_layout(barmode='stack'\n                  , height = 900)\nfig\n\n\n\n\nThe first data we’re going to add is the most common one you see in the press which is the model of the number of infected people by day.\n\n# add the series data, in plotly this is called a trace.\nfig.add_trace(\n        # This series is going to be a bar chart\n        go.Bar(\n               x = x_days       # the x-values are defined by the list of days generated earlier\n              ,y = y_infected   # the y-values are defined by the daily infected figures calculated in our loop\n              , name='Infected' # name the series \n              , marker = dict(color='red') # color the series red\n              ))\n\nx=1 # ignore this, I put this here to avoid seing the output in the notebook\n\nNext, we’ll add the susceptible numbers to see how they evolve in relation to the infected population\n\nfig.add_trace(\n        go.Bar( x = x_days\n              , y = y_susceptible\n              , name='Susceptible'\n              , marker = dict(color='rgba(0,0,255,0.5)')  # interesting thing about the color values in plotly, \n                                                          # you can use rgba to set an alpha value to increase the \n                                                          # transparency\n              )\n              )\n\nx=1 # ignore this, I put this here to avoid seing the output in the notebook\n\nFinally, we’ll add the removed category to the figure.\n\nfig.add_trace(\n        go.Bar(x = x_days\n              ,y = y_removed\n              , name='Removed'\n              , opacity=0.5))\n\nx=1 # ignore this, I put this here to avoid seing the output in the notebook"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html",
    "href": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html",
    "title": "Python 104",
    "section": "",
    "text": "import pandas as pd  # Loading the NYC dataset \nimport numpy as np   # performing fast calculations to build our simulation\nimport plotly.express as px # Quick visuals for data exploration\nfrom ipywidgets import widgets # sliders, buttons and visual layout of the dashboard\nimport plotly.graph_objects as go # plotly objects to place on our graph\nimport math # python mathematical functions\n\n\n\n\n# We'll set some easy defaults for this function so that we immediately have outputs which make some sense when we execute this method.\ndef calculate_values_SIR(removal_rate = .1\n                         , infection_rate = 1.1\n                         , population = 1000\n                         , days = 150\n                         , initial_infection  = 1\n                         \n                         # we've added this additional parameter which allows us to cut the \n                         # infection rate by 2 at a given day to simulate drastic policy action.\n                         , intervention_day = 50\n                        ):\n    \n    # build out starting positions\n    x_days = np.linspace(0,days, days)\n    y_susceptible = [population]\n    y_infected = [initial_infection]\n    y_removed = [0]\n    \n    \n    for day in x_days[1:days-1]:\n        \n        # if this day is after the day drastic intervention is made, reduce the infection rate by 2.\n        if day &gt; intervention_day:\n            infection_rate = infection_rate / 2\n            \n        day = int(day)\n        \n        daily_infected = min((infection_rate * y_infected[day-1] * (y_susceptible[day-1])/population), y_susceptible[day-1])\n        daily_removed = removal_rate * y_infected[day-1]\n        \n        y_susceptible.append( y_susceptible[day-1] - daily_infected )\n        y_infected.append(    y_infected[day-1] + daily_infected - daily_removed )\n        y_removed.append(   y_removed[day-1] + daily_removed )\n    \n    return {'infected': np.rint(y_infected)\n            , 'removed' : np.rint(y_removed)\n            , 'susceptible': np.rint(y_susceptible)}\n        \n    \n\n\n\n\n\n# This slider works with floating point numbers (hence being called Float Slider) and \n# allows us to set a variable with this slider. This is going to be the way we set the \n# infection rate.\nir = widgets.FloatSlider(\n                value=1.187, # this is the initial value of our slider when it appears\n                min=0.0,     # the minimum value we'll allow\n                max=5.0,     # the maximum value we'll allow\n                step=.001,   # by what increments the slider will change when we move it\n                description='Infection_rate:', # the name of the slider\n                continuous_update=False # Will this slider wait until it stops moving to \n                                        # call it's update function or does it call the \n                                        # update function immediately?\n)\n\nrr = widgets.FloatSlider(\n                value=.46,\n                min=0.1,     # this is set to greater than 0 because this is the denominator in the R0 calculation\n                max=2.0,\n                step=.01,\n                description='Removal_Rate:',\n                continuous_update=False\n)\n\n\nii = widgets.IntSlider(\n                value=1,\n                min=1,\n                max=50,\n                step=1,\n                description='Initially Infected:',\n                continuous_update=False\n)\n\nip = widgets.IntSlider(\n                value=1000,\n                min=500,\n                max=10_000_000,\n                step=500,\n                description='Initial Population:',\n                continuous_update=False\n)\n\n\niday = widgets.IntSlider(\n                value=15,\n                min=1,\n                max=500,\n                step=1,\n                description='Day of intervention (reducing infection rate):',\n                continuous_update=False\n)\n\n\nfirst_slider_group = widgets.HBox(children=[ir, rr])\nsecond_slider_group = widgets.HBox(children=[ii, ip, iday])\n\n\n\n\n\n# First, we use the method created above to calculate a model using the initial\n# values of the sliders we just created. Given that at this point we haven't \n# displayed the sliders yet, their values will be the default values we set above.\n\ndata = calculate_values_SIR(  removal_rate = rr.value\n                            , infection_rate = ir.value\n                            , population = ip.value\n                            , days = 150\n                            , initial_infection  = ii.value\n                            , intervention_day = iday.value\n                        )\n\n# Next we add all the data traces to the chart\n\ninfected_trace =  go.Bar(x = list(range(1,len(data['infected'])))\n              ,y = data['infected']\n              , name='Infected'\n              , marker = dict(color='red')\n              )\n\nsusceptible_trace = go.Bar(x = list(range(1, len(data['susceptible'])))\n              , y = data['susceptible']\n              , name='Susceptible'\n              , marker = dict(color='rgba(0,0,255,0.5)')\n              , opacity=0.5\n              )\n\nremoved_trace = go.Bar(x =list(range(1, len(data['removed'])))\n              ,y = data['removed']\n              , name='Removed'\n              , marker = dict(color='rgba(0,128,0,0.5)')\n              , opacity=0.5)\n\n# This trace is interesting as it's basically just drawing a straight line on the \n# selected intervention day.\n\nintervention_day = go.Scatter(x = [iday.value, iday.value]\n              ,y = [0, ip.value]\n              , name='Intervention day'\n              , marker = dict(color='darkblue')\n              , line = dict(width=5)\n  )\n\n# We create our figure adding all the traces we created to the data list, and setting some layout values in the layout parameter.\ng = go.FigureWidget(data=[ infected_trace, removed_trace, susceptible_trace, intervention_day ],\n                    layout=go.Layout(\n                         title={\n                                'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ir.value/ 2* rr.value} &lt;br /&gt;Infection_rate={ir.value} Removal_rate={rr.value}',\n                                'y':.95,\n                                'x':0.5,\n                                'xanchor': 'center',\n                                'yanchor': 'top'}\n                        ,barmode='stack'\n                        ,hovermode='x'\n                        ,height=900\n                        ,xaxis=dict(title='Number of Days')\n                        ,yaxis=dict(title='Number of People')\n                    ))\n\n# This is to update the x-axis range to show only the days where we have cases\ng.update_xaxes(range=[0,np.where(data['infected']==0)[0][0]])\n\nx=1\n\n\n\n\n\n# This method will be called any time one of the sliders is modified. It will re-run our model calculation\n# with the new values and update the data for the 4 traces we added to the figure. \ndef response(change):\n\n    num_days=150\n    \n    # recalculate the model using the new values defined by the sliders\n    pop_values = calculate_values_SIR(removal_rate = rr.value\n                                      , infection_rate=ir.value\n                                     , initial_infection=ii.value\n                                      , population=ip.value\n                                      , days=num_days\n                                     , intervention_day = iday.value)\n\n    # Try to find the first day where we have no more infections, \n    # if that fails and we get an error, use the maximum number of \n    # days for which we've calculated the model. We use this later \n    # to update the x-axis range to keep our curve centered.\n    try:\n        end_infection = np.where(pop_values['infected']==0)[0][0]\n    except IndexError:\n        end_infection = num_days\n    \n    # plotly updates much faster if you send all the updates in one go, \n    # this construct allows us to open an update session on our chart\n    # and when we leave it, it will send all the updates to the figure \n    # at once.\n    with g.batch_update():\n        # update the y-axis values from the model\n        g.data[0].y = pop_values['infected']\n        g.data[1].y = pop_values['removed']\n        g.data[2].y = pop_values['susceptible']\n        \n        # update the x-axis values \n        g.data[0].x = list(range(1,num_days))\n        g.data[1].x = list(range(1,num_days))\n        g.data[2].x = list(range(1,num_days))\n        \n        # Add the intervention day line\n        g.data[3].y = [0         , ip.value]\n        g.data[3].x = [iday.value, iday.value]\n        \n        # update the title to show the R values as well as the infection rate and the removal rate\n        g.layout.title = {\n                        'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ir.value/ 2* rr.value} &lt;br /&gt; Infection_rate={ir.value} Removal_rate={rr.value}',\n                        'x':0.5,\n                        'xanchor': 'center',\n                        'yanchor': 'top'}\n        \n        # change the x-axis range to keep the infection curve in scope\n        g.layout.xaxis = dict(range=[0,end_infection])\n        \n        \n        \n# Update each of the widgets and register our update method as the method to \n# call when they change.\nir.observe(response, names='value')\nrr.observe(response, names='value')\nii.observe(response, names='value')\nip.observe(response, names='value')\niday.observe(response, names='value')\n\n# put the widgets, and our chart together into our layout\nwidgets.VBox([first_slider_group, second_slider_group, g])"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html#building-on-the-code-from-last-week",
    "href": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html#building-on-the-code-from-last-week",
    "title": "Python 104",
    "section": "",
    "text": "import pandas as pd  # Loading the NYC dataset \nimport numpy as np   # performing fast calculations to build our simulation\nimport plotly.express as px # Quick visuals for data exploration\nfrom ipywidgets import widgets # sliders, buttons and visual layout of the dashboard\nimport plotly.graph_objects as go # plotly objects to place on our graph\nimport math # python mathematical functions\n\n\n\n\n# We'll set some easy defaults for this function so that we immediately have outputs which make some sense when we execute this method.\ndef calculate_values_SIR(removal_rate = .1\n                         , infection_rate = 1.1\n                         , population = 1000\n                         , days = 150\n                         , initial_infection  = 1\n                         \n                         # we've added this additional parameter which allows us to cut the \n                         # infection rate by 2 at a given day to simulate drastic policy action.\n                         , intervention_day = 50\n                        ):\n    \n    # build out starting positions\n    x_days = np.linspace(0,days, days)\n    y_susceptible = [population]\n    y_infected = [initial_infection]\n    y_removed = [0]\n    \n    \n    for day in x_days[1:days-1]:\n        \n        # if this day is after the day drastic intervention is made, reduce the infection rate by 2.\n        if day &gt; intervention_day:\n            infection_rate = infection_rate / 2\n            \n        day = int(day)\n        \n        daily_infected = min((infection_rate * y_infected[day-1] * (y_susceptible[day-1])/population), y_susceptible[day-1])\n        daily_removed = removal_rate * y_infected[day-1]\n        \n        y_susceptible.append( y_susceptible[day-1] - daily_infected )\n        y_infected.append(    y_infected[day-1] + daily_infected - daily_removed )\n        y_removed.append(   y_removed[day-1] + daily_removed )\n    \n    return {'infected': np.rint(y_infected)\n            , 'removed' : np.rint(y_removed)\n            , 'susceptible': np.rint(y_susceptible)}\n        \n    \n\n\n\n\n\n# This slider works with floating point numbers (hence being called Float Slider) and \n# allows us to set a variable with this slider. This is going to be the way we set the \n# infection rate.\nir = widgets.FloatSlider(\n                value=1.187, # this is the initial value of our slider when it appears\n                min=0.0,     # the minimum value we'll allow\n                max=5.0,     # the maximum value we'll allow\n                step=.001,   # by what increments the slider will change when we move it\n                description='Infection_rate:', # the name of the slider\n                continuous_update=False # Will this slider wait until it stops moving to \n                                        # call it's update function or does it call the \n                                        # update function immediately?\n)\n\nrr = widgets.FloatSlider(\n                value=.46,\n                min=0.1,     # this is set to greater than 0 because this is the denominator in the R0 calculation\n                max=2.0,\n                step=.01,\n                description='Removal_Rate:',\n                continuous_update=False\n)\n\n\nii = widgets.IntSlider(\n                value=1,\n                min=1,\n                max=50,\n                step=1,\n                description='Initially Infected:',\n                continuous_update=False\n)\n\nip = widgets.IntSlider(\n                value=1000,\n                min=500,\n                max=10_000_000,\n                step=500,\n                description='Initial Population:',\n                continuous_update=False\n)\n\n\niday = widgets.IntSlider(\n                value=15,\n                min=1,\n                max=500,\n                step=1,\n                description='Day of intervention (reducing infection rate):',\n                continuous_update=False\n)\n\n\nfirst_slider_group = widgets.HBox(children=[ir, rr])\nsecond_slider_group = widgets.HBox(children=[ii, ip, iday])\n\n\n\n\n\n# First, we use the method created above to calculate a model using the initial\n# values of the sliders we just created. Given that at this point we haven't \n# displayed the sliders yet, their values will be the default values we set above.\n\ndata = calculate_values_SIR(  removal_rate = rr.value\n                            , infection_rate = ir.value\n                            , population = ip.value\n                            , days = 150\n                            , initial_infection  = ii.value\n                            , intervention_day = iday.value\n                        )\n\n# Next we add all the data traces to the chart\n\ninfected_trace =  go.Bar(x = list(range(1,len(data['infected'])))\n              ,y = data['infected']\n              , name='Infected'\n              , marker = dict(color='red')\n              )\n\nsusceptible_trace = go.Bar(x = list(range(1, len(data['susceptible'])))\n              , y = data['susceptible']\n              , name='Susceptible'\n              , marker = dict(color='rgba(0,0,255,0.5)')\n              , opacity=0.5\n              )\n\nremoved_trace = go.Bar(x =list(range(1, len(data['removed'])))\n              ,y = data['removed']\n              , name='Removed'\n              , marker = dict(color='rgba(0,128,0,0.5)')\n              , opacity=0.5)\n\n# This trace is interesting as it's basically just drawing a straight line on the \n# selected intervention day.\n\nintervention_day = go.Scatter(x = [iday.value, iday.value]\n              ,y = [0, ip.value]\n              , name='Intervention day'\n              , marker = dict(color='darkblue')\n              , line = dict(width=5)\n  )\n\n# We create our figure adding all the traces we created to the data list, and setting some layout values in the layout parameter.\ng = go.FigureWidget(data=[ infected_trace, removed_trace, susceptible_trace, intervention_day ],\n                    layout=go.Layout(\n                         title={\n                                'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ir.value/ 2* rr.value} &lt;br /&gt;Infection_rate={ir.value} Removal_rate={rr.value}',\n                                'y':.95,\n                                'x':0.5,\n                                'xanchor': 'center',\n                                'yanchor': 'top'}\n                        ,barmode='stack'\n                        ,hovermode='x'\n                        ,height=900\n                        ,xaxis=dict(title='Number of Days')\n                        ,yaxis=dict(title='Number of People')\n                    ))\n\n# This is to update the x-axis range to show only the days where we have cases\ng.update_xaxes(range=[0,np.where(data['infected']==0)[0][0]])\n\nx=1\n\n\n\n\n\n# This method will be called any time one of the sliders is modified. It will re-run our model calculation\n# with the new values and update the data for the 4 traces we added to the figure. \ndef response(change):\n\n    num_days=150\n    \n    # recalculate the model using the new values defined by the sliders\n    pop_values = calculate_values_SIR(removal_rate = rr.value\n                                      , infection_rate=ir.value\n                                     , initial_infection=ii.value\n                                      , population=ip.value\n                                      , days=num_days\n                                     , intervention_day = iday.value)\n\n    # Try to find the first day where we have no more infections, \n    # if that fails and we get an error, use the maximum number of \n    # days for which we've calculated the model. We use this later \n    # to update the x-axis range to keep our curve centered.\n    try:\n        end_infection = np.where(pop_values['infected']==0)[0][0]\n    except IndexError:\n        end_infection = num_days\n    \n    # plotly updates much faster if you send all the updates in one go, \n    # this construct allows us to open an update session on our chart\n    # and when we leave it, it will send all the updates to the figure \n    # at once.\n    with g.batch_update():\n        # update the y-axis values from the model\n        g.data[0].y = pop_values['infected']\n        g.data[1].y = pop_values['removed']\n        g.data[2].y = pop_values['susceptible']\n        \n        # update the x-axis values \n        g.data[0].x = list(range(1,num_days))\n        g.data[1].x = list(range(1,num_days))\n        g.data[2].x = list(range(1,num_days))\n        \n        # Add the intervention day line\n        g.data[3].y = [0         , ip.value]\n        g.data[3].x = [iday.value, iday.value]\n        \n        # update the title to show the R values as well as the infection rate and the removal rate\n        g.layout.title = {\n                        'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ir.value/ 2* rr.value} &lt;br /&gt; Infection_rate={ir.value} Removal_rate={rr.value}',\n                        'x':0.5,\n                        'xanchor': 'center',\n                        'yanchor': 'top'}\n        \n        # change the x-axis range to keep the infection curve in scope\n        g.layout.xaxis = dict(range=[0,end_infection])\n        \n        \n        \n# Update each of the widgets and register our update method as the method to \n# call when they change.\nir.observe(response, names='value')\nrr.observe(response, names='value')\nii.observe(response, names='value')\nip.observe(response, names='value')\niday.observe(response, names='value')\n\n# put the widgets, and our chart together into our layout\nwidgets.VBox([first_slider_group, second_slider_group, g])"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html#add-an-intervention-effectiveness-measure",
    "href": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html#add-an-intervention-effectiveness-measure",
    "title": "Python 104",
    "section": "Add an intervention effectiveness measure",
    "text": "Add an intervention effectiveness measure\nWe’re going to add an additional slider to allow us to control how effective the intervention measure is.\n\n\n# We'll set some easy defaults for this function so that we immediately have outputs which make some sense when we execute this method.\ndef calculate_values_SIR(removal_rate = .1\n                         , infection_rate = 1.1\n                         , population = 1000\n                         , days = 150\n                         , initial_infection  = 1\n                         \n                         # we've added this additional parameter which allows us to cut the \n                         # infection rate by 2 at a given day to simulate drastic policy action.\n                         , intervention_day = 50\n                         , intervention_effectiveness = .46\n                        ):\n    \n    # build out starting positions\n    x_days = np.linspace(0,days, days)\n    y_susceptible = [population]\n    y_infected = [initial_infection]\n    y_removed = [0]\n    \n    \n    for day in x_days[1:days-1]:\n        \n        # if this day is after the day drastic intervention is made, reduce the infection rate by 2.\n        if day &gt; intervention_day:\n            infection_rate = infection_rate * max((1-intervention_effectiveness),0)\n            \n        day = int(day)\n        \n        daily_infected = min((infection_rate * y_infected[day-1] * (y_susceptible[day-1])/population), y_susceptible[day-1])\n        daily_removed = removal_rate * y_infected[day-1]\n        \n        y_susceptible.append( y_susceptible[day-1] - daily_infected )\n        y_infected.append(    y_infected[day-1] + daily_infected - daily_removed )\n        y_removed.append(   y_removed[day-1] + daily_removed )\n    \n    return {'infected': np.rint(y_infected)\n            , 'removed' : np.rint(y_removed)\n            , 'susceptible': np.rint(y_susceptible)}\n        \n    \n# This slider works with floating point numbers (hence being called Float Slider) and \n# allows us to set a variable with this slider. This is going to be the way we set the \n# infection rate.\nir = widgets.FloatSlider(\n                value=1.187, # this is the initial value of our slider when it appears\n                min=0.0,     # the minimum value we'll allow\n                max=5.0,     # the maximum value we'll allow\n                step=.001,   # by what increments the slider will change when we move it\n                description='Infection_rate:', # the name of the slider\n                continuous_update=False # Will this slider wait until it stops moving to \n                                        # call it's update function or does it call the \n                                        # update function immediately?\n)\n\nrr = widgets.FloatSlider(\n                value=.46,\n                min=0.1,     # this is set to greater than 0 because this is the denominator in the R0 calculation\n                max=2.0,\n                step=.01,\n                description='Removal_Rate:',\n                continuous_update=False\n)\n\n\nii = widgets.IntSlider(\n                value=1,\n                min=1,\n                max=50,\n                step=1,\n                description='Initially Infected:',\n                continuous_update=False\n)\n\nip = widgets.IntSlider(\n                value=1000,\n                min=500,\n                max=10_000_000,\n                step=500,\n                description='Initial Population:',\n                continuous_update=False\n)\n\n\niday = widgets.IntSlider(\n                value=15,\n                min=1,\n                max=500,\n                step=1,\n                description='Day of intervention (reducing infection rate):',\n                continuous_update=False\n)\n\nie = widgets.FloatSlider(\n                value=.46,\n                min=0.0,    \n                max=1.0,\n                step=.01,\n                description='Intervention effectiveness:',\n                continuous_update=False\n)\n\n\n\nfirst_slider_group = widgets.HBox(children=[ir, rr, ie])\nsecond_slider_group = widgets.HBox(children=[ii, ip, iday])\n\n\n# First, we use the method created above to calculate a model using the initial\n# values of the sliders we just created. Given that at this point we haven't \n# displayed the sliders yet, their values will be the default values we set above.\n\ndata = calculate_values_SIR(  removal_rate = rr.value\n                            , infection_rate = ir.value\n                            , population = ip.value\n                            , days = 150\n                            , initial_infection  = ii.value\n                            , intervention_day = iday.value\n                            , intervention_effectiveness= ie.value\n                        )\n\n# Next we add all the data traces to the chart\n\ninfected_trace =  go.Bar(x = list(range(1,len(data['infected'])))\n              ,y = data['infected']\n              , name='Infected'\n              , marker = dict(color='red')\n              )\n\nsusceptible_trace = go.Bar(x = list(range(1, len(data['susceptible'])))\n              , y = data['susceptible']\n              , name='Susceptible'\n              , marker = dict(color='rgba(0,0,255,0.5)')\n              , opacity=0.5\n              )\n\nremoved_trace = go.Bar(x =list(range(1, len(data['removed'])))\n              ,y = data['removed']\n              , name='Removed'\n              , marker = dict(color='rgba(0,128,0,0.5)')\n              , opacity=0.5)\n\n# This trace is interesting as it's basically just drawing a straight line on the \n# selected intervention day.\n\nintervention_day = go.Scatter(x = [iday.value, iday.value]\n              ,y = [0, ip.value]\n              , name='Intervention day'\n              , marker = dict(color='darkblue')\n              , line = dict(width=5)\n  )\n\n# We create our figure adding all the traces we created to the data list, and setting some layout values in the layout parameter.\ng = go.FigureWidget(data=[ infected_trace, removed_trace, susceptible_trace, intervention_day ],\n                    layout=go.Layout(\n                         title={\n                                'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {(ir.value * .46) / rr.value} &lt;br /&gt;Infection_rate={ir.value} Removal_rate={rr.value}',\n                                'y':.95,\n                                'x':0.5,\n                                'xanchor': 'center',\n                                'yanchor': 'top'}\n                        ,barmode='stack'\n                        ,hovermode='x'\n                        ,height=900\n                        ,xaxis=dict(title='Number of Days')\n                        ,yaxis=dict(title='Number of People')\n                    ))\n\n# This is to update the x-axis range to show only the days where we have cases\ng.update_xaxes(range=[0,np.where(data['infected']==0)[0][0]])\n\nx=1\n\n\n# This method will be called any time one of the sliders is modified. It will re-run our model calculation\n# with the new values and update the data for the 4 traces we added to the figure. \ndef response(change):\n\n    num_days=150\n    \n    # recalculate the model using the new values defined by the sliders\n    pop_values = calculate_values_SIR(removal_rate = rr.value\n                                      , infection_rate=ir.value\n                                     , initial_infection=ii.value\n                                      , population=ip.value\n                                      , days=num_days\n                                     , intervention_day = iday.value\n                                     , intervention_effectiveness= ie.value\n                                     )\n\n    # Try to find the first day where we have no more infections, \n    # if that fails and we get an error, use the maximum number of \n    # days for which we've calculated the model. We use this later \n    # to update the x-axis range to keep our curve centered.\n    try:\n        end_infection = np.where(pop_values['infected']==0)[0][0]\n    except IndexError:\n        end_infection = num_days\n    \n    # plotly updates much faster if you send all the updates in one go, \n    # this construct allows us to open an update session on our chart\n    # and when we leave it, it will send all the updates to the figure \n    # at once.\n    with g.batch_update():\n        # update the y-axis values from the model\n        g.data[0].y = pop_values['infected']\n        g.data[1].y = pop_values['removed']\n        g.data[2].y = pop_values['susceptible']\n        \n        # update the x-axis values \n        g.data[0].x = list(range(1,num_days))\n        g.data[1].x = list(range(1,num_days))\n        g.data[2].x = list(range(1,num_days))\n        \n        # Add the intervention day line\n        g.data[3].y = [0         , ip.value]\n        g.data[3].x = [iday.value, iday.value]\n        \n        # update the title to show the R values as well as the infection rate and the removal rate\n        \n        ie_rate = ir.value * max((1-ie.value),0)\n        g.layout.title = {\n                        'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ie_rate / rr.value} &lt;br /&gt; Infection_rate={ir.value} Removal_rate={rr.value}',\n                        'x':0.5,\n                        'xanchor': 'center',\n                        'yanchor': 'top'}\n        \n        # change the x-axis range to keep the infection curve in scope\n        g.layout.xaxis = dict(range=[0,end_infection])\n        \n        \n        \n# Update each of the widgets and register our update method as the method to \n# call when they change.\nir.observe(response, names='value')\nrr.observe(response, names='value')\nii.observe(response, names='value')\nip.observe(response, names='value')\niday.observe(response, names='value')\nie.observe(response, names='value')\n\n# put the widgets, and our chart together into our layout\nwidgets.VBox([first_slider_group, second_slider_group, g])"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html#add-display-the-effectiveness-vs-the-rate-had-there-been-no-change",
    "href": "notebooks/coffee course/introduction-to-SIR-models-2/introduction-to-SIR-models-2.html#add-display-the-effectiveness-vs-the-rate-had-there-been-no-change",
    "title": "Python 104",
    "section": "Add display the effectiveness vs the rate had there been no change",
    "text": "Add display the effectiveness vs the rate had there been no change\n\nUpdate the calculation method\nThe first thing we need to do if we want to show the effectiveness of the intervention at the same time as what happens after an intervention is to update the calculation method to calculate both the intervened infectious rates and the un-intervened infectious rates at the same time. This sounds more complex than it actually is, all we need to do during this is keep track of how many people would have been infected/removed if there had been no intervention and subtract the intervened numbers from that.\nTo that end, we need to keep track of 2 additional numbers for every day: - The number of people we need to add to the infected group to count how many would be infected if there were no intervention. - The number of people we need to add to the removed group if there were no intervention.\nTo denote such non -intervention figures in the code we’re going to append values with ‘_noi’ so that we can keep track of the changes.\n\n# We'll set some easy defaults for this function so that we immediately have outputs which make some sense when we execute this method.\ndef calculate_values_SIR(removal_rate = .1\n                         , infection_rate = 1.1\n                         , population = 1000\n                         , days = 150\n                         , initial_infection  = 1\n                           \n                         , incubation_period = 10\n                         , fatality_rate = .03\n                         , immunity_duration = 30\n                         \n                         # we've added this additional parameter which allows us to cut the \n                         # infection rate by 2 at a given day to simulate drastic policy action.\n                         , intervention_day = 50\n                         , intervention_effectiveness = .46\n                        ):\n    \n    # build out starting positions\n    x_days = np.linspace(0,days, days)\n    y_susceptible = [population]\n    y_infected = [initial_infection]\n    y_removed = [0]\n    \n    y_infected_noi = [0]\n    y_removed_noi = [0]\n    \n    \n    for day in x_days[1:days-1]:\n        \n        # if this day is after the day drastic intervention is made, reduce the infection rate by 2.\n        if day &gt;= intervention_day:\n            inter_infection_rate = infection_rate * max((1-intervention_effectiveness),0)\n        else:\n            inter_infection_rate = infection_rate\n            \n        day = int(day)\n        \n        # Calculate the number of people susceptible from the previous day \n        pday_susceptible = y_susceptible[day-1] + y_infected_noi[day-1]\n        \n        daily_infected = min((inter_infection_rate * y_infected[day-1] * (pday_susceptible)/population), pday_susceptible)\n        daily_removed = removal_rate * y_infected[day-1]\n        \n        # If we're after the intevention, caluclate what would have happened and update the \n        # hypothetical values\n        if day &gt;= intervention_day:\n            \n            # calculate the hypothetical number of infected\n            pday_infected_noi = y_infected[day-1] + y_infected_noi[day-1]\n            \n            # Calculate the hypothetical daily infected rates\n            daily_infected_noi = min((infection_rate * (pday_infected_noi) * ( y_susceptible[day-1])/population), y_susceptible[day-1]) - daily_infected\n            \n            # Calculate the hyothetical daily removed rate\n            daily_removed_noi = (removal_rate * (pday_infected_noi)) \n            \n            # Calculate our daily removed additional values \n            noi_removed = max(daily_removed_noi - daily_removed, 0 )\n            \n            # Keep track of our unintervened infected and removed values\n            y_infected_noi.append(y_infected_noi[day-1] + (daily_infected_noi) - (noi_removed))\n            y_removed_noi.append( y_removed_noi[day-1] + (noi_removed))\n            \n        else:\n            daily_infected_noi = 0\n            daily_removed_noi = 0\n            y_infected_noi.append(0)\n            y_removed_noi.append(0)\n        \n        y_susceptible.append( y_susceptible[day-1] - (daily_infected + (daily_infected_noi)))\n        y_infected.append(    y_infected[day-1] + daily_infected - daily_removed )\n        y_removed.append(   y_removed[day-1] + daily_removed )\n    \n    return {'infected': np.rint(y_infected)\n            , 'removed' : np.rint(y_removed)\n            , 'susceptible': np.rint(y_susceptible)\n            , 'infected_noi': np.rint(y_infected_noi)\n            , 'removed_noi': np.rint(y_removed_noi) }\n    \n\n\ndata = calculate_values_SIR(  removal_rate = rr.value\n                            , infection_rate = ir.value\n                            , population = ip.value\n                            , days = 150\n                            , initial_infection  = ii.value\n                            , intervention_day = 15\n                        )\n\n\n\ndata\n\n{'infected': array([  1.,   2.,   3.,   5.,   9.,  15.,  26.,  43.,  71., 113., 169.,\n        231., 279., 285., 246., 161., 103.,  64.,  39.,  23.,  14.,   8.,\n          5.,   3.,   2.,   1.,   1.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n          0.,   0.,   0.,   0.,   0.,   0.]),\n 'removed': array([  0.,   0.,   1.,   3.,   5.,   9.,  16.,  28.,  48.,  80., 132.,\n        210., 316., 444., 575., 688., 762., 810., 839., 857., 867., 874.,\n        877., 880., 881., 882., 882., 882., 882., 882., 882., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883., 883., 883., 883., 883., 883.,\n        883., 883., 883., 883., 883., 883.]),\n 'susceptible': array([1000.,  999.,  997.,  993.,  987.,  977.,  959.,  930.,  882.,\n         808.,  700.,  560.,  406.,  272.,  180.,  127.,   99.,   84.,\n          76.,   71.,   68.,   66.,   65.,   65.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,   64.,\n          64.,   64.,   64.,   64.,   64.]),\n 'infected_noi': array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0., 24., 25., 21., 15., 11.,  8.,  5.,  3.,  2.,  1.,  1.,\n         1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0.,  0.,  0.,  0.]),\n 'removed_noi': array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,\n         0.,  0.,  0., 11., 23., 32., 39., 44., 48., 50., 52., 53., 53.,\n        54., 54., 54., 54., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55., 55.,\n        55., 55., 55., 55., 55., 55.])}\n\n\n\n# This slider works with floating point numbers (hence being called Float Slider) and \n# allows us to set a variable with this slider. This is going to be the way we set the \n# infection rate.\nir = widgets.FloatSlider(\n                value=1.187, # this is the initial value of our slider when it appears\n                min=0.0,     # the minimum value we'll allow\n                max=5.0,     # the maximum value we'll allow\n                step=.001,   # by what increments the slider will change when we move it\n                description='Infection_rate:', # the name of the slider\n                continuous_update=False # Will this slider wait until it stops moving to \n                                        # call it's update function or does it call the \n                                        # update function immediately?\n)\n\nrr = widgets.FloatSlider(\n                value=.46,\n                min=0.1,     # this is set to greater than 0 because this is the denominator in the R0 calculation\n                max=2.0,\n                step=.01,\n                description='Removal_Rate:',\n                continuous_update=False\n)\n\n\nii = widgets.IntSlider(\n                value=1,\n                min=1,\n                max=50,\n                step=1,\n                description='Initially Infected:',\n                continuous_update=False\n)\n\nip = widgets.IntSlider(\n                value=1000,\n                min=500,\n                max=10_000_000,\n                step=500,\n                description='Initial Population:',\n                continuous_update=False\n)\n\n\niday = widgets.IntSlider(\n                value=15,\n                min=1,\n                max=150,\n                step=1,\n                description='Day of intervention (reducing infection rate):',\n                continuous_update=False\n)\n\n\nie = widgets.FloatSlider(\n                value=.46,\n                min=0.0,    \n                max=1.0,\n                step=.01,\n                description='Intervention effectiveness:',\n                continuous_update=False\n)\n\n\n\nfirst_slider_group = widgets.HBox(children=[ir, rr, ie])\nsecond_slider_group = widgets.HBox(children=[ii, ip, iday])\n\n# First, we use the method created above to calculate a model using the initial\n# values of the sliders we just created. Given that at this point we haven't \n# displayed the sliders yet, their values will be the default values we set above.\n\ndata = calculate_values_SIR(  removal_rate = rr.value\n                            , infection_rate = ir.value\n                            , population = ip.value\n                            , days = 150\n                            , initial_infection  = ii.value\n                            , intervention_day = iday.value\n                        )\n\n# Next we add all the data traces to the chart\n\ninfected_trace =  go.Bar(x = list(range(1,len(data['infected'])))\n              ,y = data['infected']\n              , name='Infected'\n              , marker = dict(color='red')\n              )\n\nsusceptible_trace = go.Bar(x = list(range(1, len(data['susceptible'])))\n              , y = data['susceptible']\n              , name='Susceptible'\n              , marker = dict(color='rgba(0,0,255,0.5)')\n              , opacity=0.5\n              )\n\nremoved_trace = go.Bar(x =list(range(1, len(data['removed'])))\n              ,y = data['removed']\n              , name='Removed'\n              , marker = dict(color='rgba(0,128,0,0.5)')\n              , opacity=0.5)\n\n######\n# ADDITION STARTS HERE\n######\n\n\ninfected_trace_noi =  go.Bar(x = list(range(1,len(data['infected_noi'])))\n              ,y = data['infected_noi']\n              , name='Infected No Intervention'\n              , marker = dict(color='rgba(225,0,0,0.5)')\n              )\n\n\nremoved_trace_noi = go.Bar(x =list(range(1, len(data['removed_noi'])))\n              ,y = data['removed_noi']\n              , name='Removed No Intervention'\n              , marker = dict(color='rgba(0,225,0,0.5)')\n              )\n\n######\n# ADDITION END HERE\n######\n\n\n# This trace is interesting as it's basically just drawing a straight line on the \n# selected intervention day.\n\nintervention_day = go.Scatter(x = [iday.value, iday.value]\n              ,y = [0, ip.value]\n              , name='Intervention day'\n              , marker = dict(color='darkblue')\n              , line = dict(width=5)\n  )\n\n# We create our figure adding all the traces we created to the data list, and setting some layout values in the layout parameter.\ng = go.FigureWidget(data=[ infected_trace\n                          , infected_trace_noi\n                          , removed_trace\n                          , susceptible_trace\n                          , intervention_day\n                          ,  removed_trace_noi ],\n                    layout=go.Layout(\n                         title={\n                                'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ir.value/ 2* rr.value} &lt;br /&gt;Infection_rate={ir.value} Removal_rate={rr.value}',\n                                'y':.95,\n                                'x':0.5,\n                                'xanchor': 'center',\n                                'yanchor': 'top'}\n                        ,barmode='stack'\n                        ,hovermode='x'\n                        ,height=600\n                        ,xaxis=dict(title='Number of Days')\n                        ,yaxis=dict(title='Number of People')\n                    ))\n\n# This is to update the x-axis range to show only the days where we have cases\ng.update_xaxes(range=[0,np.where(data['infected']==0)[0][0]])\n\nx=1\n\n# This method will be called any time one of the sliders is modified. It will re-run our model calculation\n# with the new values and update the data for the 4 traces we added to the figure. \ndef response(change):\n\n    num_days=150\n    \n    # recalculate the model using the new values defined by the sliders\n    pop_values = calculate_values_SIR(removal_rate = rr.value\n                                      , infection_rate=ir.value\n                                     , initial_infection=ii.value\n                                      , population=ip.value\n                                      , days=num_days\n                                     , intervention_day = iday.value\n                                     , intervention_effectiveness= ie.value\n                                     )\n\n    # Try to find the first day where we have no more infections, \n    # if that fails and we get an error, use the maximum number of \n    # days for which we've calculated the model. We use this later \n    # to update the x-axis range to keep our curve centered.\n    try:\n        end_infection = max( np.where(pop_values['infected_noi'][iday.value+1:]==0)[0][0] + iday.value +1,\n                             np.where(pop_values['infected']==0)[0][0] )\n    except IndexError:\n        end_infection = num_days\n    \n    # plotly updates much faster if you send all the updates in one go, \n    # this construct allows us to open an update session on our chart\n    # and when we leave it, it will send all the updates to the figure \n    # at once.\n    with g.batch_update():\n        # update the y-axis values from the model\n        g.data[0].y = pop_values['infected']\n        g.data[1].y = pop_values['infected_noi']\n        g.data[2].y = pop_values['removed']\n        g.data[3].y = pop_values['susceptible']\n        g.data[5].y = pop_values['removed_noi']\n\n        \n        # Add the intervention day line\n        g.data[4].y = [0         , ip.value]\n        g.data[4].x = [iday.value, iday.value]\n        \n        # update the title to show the R values as well as the infection rate and the removal rate\n        \n        ie_rate = ir.value * max((1-ie.value),0)\n        g.layout.title = {\n                        'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ie_rate / rr.value} &lt;br /&gt; Infection_rate={ir.value} Removal_rate={rr.value}',\n                        'x':0.5,\n                        'xanchor': 'center',\n                        'yanchor': 'top'}\n        \n        # change the x-axis range to keep the infection curve in scope\n        g.layout.xaxis = dict(range=[0,end_infection])\n        \n        \n        \n        \n# Update each of the widgets and register our update method as the method to \n# call when they change.\nir.observe(response, names='value')\nrr.observe(response, names='value')\nii.observe(response, names='value')\nip.observe(response, names='value')\niday.observe(response, names='value')\nie.observe(response, names='value')\n\n# put the widgets, and our chart together into our layout\nwidgets.VBox([first_slider_group, second_slider_group, g])"
  },
  {
    "objectID": "portfolio/sketch-shading/sketch-shading.html",
    "href": "portfolio/sketch-shading/sketch-shading.html",
    "title": "Sketch Shading",
    "section": "",
    "text": "For my Bachelors thesis (2008) I designed a method for rendering 3D models in a non-photorealistic way allowing the models to appear sketched. While the material I present in my thesis is not very complex, I present a completely novel approach to rendering models so that they appear sketched in real time."
  },
  {
    "objectID": "portfolio/sketch-shading/sketch-shading.html#abstract",
    "href": "portfolio/sketch-shading/sketch-shading.html#abstract",
    "title": "Sketch Shading",
    "section": "Abstract",
    "text": "Abstract\nThis project discusses non-photorealistic rendering techniques. In particular it examines three different outlining methods in detail and describes a fourth. Those three main outlining methods are stencil buffer outlining, front-face culling and ink sketch outlining. In addition two different shading methods – cell shading and crosshatch shading – are discussed. The cell shading method mentioned here is a commonly used method and is provided as an introduction to the crosshatch shading method. This project examines two different crosshatch shading methods, one simple and one which attempts to improve on the quality of the current crosshatch shading method on models with large polygons. All of the work presented in this paper is designed to work in real-time with speeds ranging from 24 to 60 frames per second.\nread more.."
  },
  {
    "objectID": "portfolio_draft/client-risk-factor-identification/client-risk-factor-identification.html",
    "href": "portfolio_draft/client-risk-factor-identification/client-risk-factor-identification.html",
    "title": "Identifying at-risk customers using KYC data",
    "section": "",
    "text": "In 2013 the Swiss FINMA and the US Department of Justice announced the US Program asking Swiss banks and insurance companies to self-declare whether they held accounts for US citizens which were not declared to the IRS. This declaration set off a race to identify potential US accounts in banking institutions across Swizterland.\n[[ DETAILS TO FOLLOW]]"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "notebooks.html",
    "href": "notebooks.html",
    "title": "Code explorations",
    "section": "",
    "text": "Python 102 - Plotting data on a map\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPython 104\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPython 105 - Make the SIR model more efficient and add additional parameters\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPython Coffee Courses 103 - Basic SIR modeling and how to visualize it\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2012-10-22-combining-strings-in-t-sql.html",
    "href": "posts/2012-10-22-combining-strings-in-t-sql.html",
    "title": "Combining strings in T-SQL",
    "section": "",
    "text": "I found out the other day how to solve a problem that had been causing me issues when presenting data. I often got requests to resent data in such a way that we display information from a table in a grouped form while still allowing someone to consult all of the values relating to this grouping.\nThe solution isn’t very machine friendly and is end-user oriented. The code can be seen below:\n\nSELECT\n    ta.a1,\n    ta.a2,\n    ta.a3,\n    ( SELECT\n          tta.a4,\n      FROM TABLE_A tta\n      WHERE\n          ta.a1=tta.a1\n          and ta.a2=tta.a2\n          and ta.a3=tta.a3\n      ORDER BY tta.a4\n      FOR XML PATH('')\n    ) AS a4plus\nFROM TABLE_A ta"
  },
  {
    "objectID": "posts/2012-10-10-finding-hidden-characters-in-excel.html",
    "href": "posts/2012-10-10-finding-hidden-characters-in-excel.html",
    "title": "Searching for hidden characters in Excel",
    "section": "",
    "text": "Did you know that you could search for hidden characters and replace with hidden characters in excel?\nSimply type: alt + [ASCII Code] To find any non-printable characters.\nHere are some handy Ascii codes: 0010: Carriage return (\\r) 0013: Line Feed (\\n) 0011: Tab (\\t)"
  },
  {
    "objectID": "posts/2017-01-31-pseudo-random-ids-in-sql.html",
    "href": "posts/2017-01-31-pseudo-random-ids-in-sql.html",
    "title": "Creating anonymized pseudo-random IDs in T-SQL",
    "section": "",
    "text": "I sometimes need to convert a series of unique sensitive IDs into a list of unique IDs which I can use to share with people who aren’t allowed to know the IDs in the first list. The very easiest was to do that in SQL is to either use the HASHBYTES function in T-SQL and provide it with the SHA512 hashing algorithm or to use the t-SQL newID function to create new GUIDs. The difficulty with this is that it creates a very difficult to read ID so if I started with relatively simple to remember 5 character IDs I end up with a super user unfriendly 40 character hexadecimal number.\nSo how could one scramble a friendly 6 character ID into an anonymous friendly 7 character ID? The easiest way to do this is to use some basic number theory and combine that with SQL’s NEWID() function.\n\nWe start off by getting a unique list of all the ID numbers we want to anonymize and scramble the order by using NEWID()\n\nSelect ID,\n       RandomRow = ROW_NUMBER() OVER (ORDER BY NEWID())\nINTO RandOrder\nFROM ListOfIDs\n\nWe then Take that randomly ordered list and perform some math on the order using two carefully selected primes, one is a small prime the number of digits that we want the result to be in (A), and the other is a very large prime (B). I’ve chosen only a middlingly large prime here to make reading easier. A = 7957597 B = 362736035870515331128527330659 We multiply these in the following way to create a unique list of numbers. NB, prime A must be larger than the total number of IDs you want to create or else this doesn’t work.\n\nDECLARE @A INT = 7957597\nDECLARE @B INT = 362736035870515331128527330659\nSelect ID,\n       Number = (RandomRow * @B) % @A\nINTO RandomNums\nFROM RandOrder\n\nIf we want to be fancy we can convert the integer into hex and add a prefix to denote that this is an anonymous ID. NB the size of your VARBINARY depends on the size you want your strings to be.\n\nSelect ID,\n       AnonymousID = 'RANDID' +\n          RIGHT(\n           master.dbo.fn_varbintohexstr(CONVERT(VARBINARY(8), Number))\n          ,7)\nFROM RandomNums"
  },
  {
    "objectID": "posts/2017-01-31-pseudo-random-ids-in-sql.html#creating-anonymized-pseudo-random-ids",
    "href": "posts/2017-01-31-pseudo-random-ids-in-sql.html#creating-anonymized-pseudo-random-ids",
    "title": "Creating anonymized pseudo-random IDs in T-SQL",
    "section": "",
    "text": "I sometimes need to convert a series of unique sensitive IDs into a list of unique IDs which I can use to share with people who aren’t allowed to know the IDs in the first list. The very easiest was to do that in SQL is to either use the HASHBYTES function in T-SQL and provide it with the SHA512 hashing algorithm or to use the t-SQL newID function to create new GUIDs. The difficulty with this is that it creates a very difficult to read ID so if I started with relatively simple to remember 5 character IDs I end up with a super user unfriendly 40 character hexadecimal number.\nSo how could one scramble a friendly 6 character ID into an anonymous friendly 7 character ID? The easiest way to do this is to use some basic number theory and combine that with SQL’s NEWID() function.\n\nWe start off by getting a unique list of all the ID numbers we want to anonymize and scramble the order by using NEWID()\n\nSelect ID,\n       RandomRow = ROW_NUMBER() OVER (ORDER BY NEWID())\nINTO RandOrder\nFROM ListOfIDs\n\nWe then Take that randomly ordered list and perform some math on the order using two carefully selected primes, one is a small prime the number of digits that we want the result to be in (A), and the other is a very large prime (B). I’ve chosen only a middlingly large prime here to make reading easier. A = 7957597 B = 362736035870515331128527330659 We multiply these in the following way to create a unique list of numbers. NB, prime A must be larger than the total number of IDs you want to create or else this doesn’t work.\n\nDECLARE @A INT = 7957597\nDECLARE @B INT = 362736035870515331128527330659\nSelect ID,\n       Number = (RandomRow * @B) % @A\nINTO RandomNums\nFROM RandOrder\n\nIf we want to be fancy we can convert the integer into hex and add a prefix to denote that this is an anonymous ID. NB the size of your VARBINARY depends on the size you want your strings to be.\n\nSelect ID,\n       AnonymousID = 'RANDID' +\n          RIGHT(\n           master.dbo.fn_varbintohexstr(CONVERT(VARBINARY(8), Number))\n          ,7)\nFROM RandomNums"
  },
  {
    "objectID": "posts/2014-06-11-pivoting-tables-when-you-don't-know-the-columns.html",
    "href": "posts/2014-06-11-pivoting-tables-when-you-don't-know-the-columns.html",
    "title": "Pivoting tables when you don’t know the columns in T-SQL",
    "section": "",
    "text": "Here’s the situation, you’ve got a column in a table which you want to pivot on but you don’t have any control over the distinct number of values that can be in that column. It could be 3 or it could be 20. However, you still need to be able to pivot the whole table to display the information to the user. How do you do this?\nThe answer here lies in the way you can use string variables as code in dynamic SQL, and there are two parts of the pivot code which have become variables in the situation outlined above:\nSELECT\n    UnPivotedColumn1,\n    --Variable Block #1\n    PivotVal1,\n    ...\n    PivotValX\n    --End: VB #1\nFROM (\n    SELECT UnPivotedColumn1\n                ,PivotSource --Contains values PivotVal1 - X\n                ,ColToAggregate\n    FROM TableYouWantToPivot\n) tbl\nPIVOT\n(\nSUM(ColToAggregate)\n\nFOR PivotSource\nIN (\n   --Variable Block #2\n   [PivotVal1], ... , [PivotValX]\n   --End: VB #2\n   )\n\n) pvt\nTherefore, to create this pivot when we have a variable number of values in our PivotSource column we need to populate two strings with the distinct values of the PivotSource Column – Variable Block #1 and Variable Block #2.\nTo do this we will use the method I explained in an earlier post. For Variable Block #1 the code looks like:\nDECLARE @VB1 VARCHAR(MAX);\n\nSET @VB1 = STUFF(\n          SELECT ', ' + PivotSource\n          FROM TableYouWantToPivot\n          FOR XML PATH(''),\n          1,2,'')\n\n&lt;/pre&gt;\nThe stuff command here removes the comma at the beginning so that we have a comma-separated list of values and no trailing comma.\n\nThe code for Variable block #2 is similar but formatted slightly differently.\n&lt;pre lang=\"sql\"&gt;DECLARE @VB1 VARCHAR(MAX);\n\nSET @VB1 = STUFF(\n          SELECT ', [' + PivotSource + ']'\n          FROM TableYouWantToPivot\n          FOR XML PATH(''),\n          1,2,'')\nFinally we need to construct our Dynamic SQL statement that we need to execute:\nDECLARE @SQLPivot VARCHAR(MAX)\n\nSET @SQLPivot = '\n  SELECT\n      UnPivotedColumn1,\n      ' + @VB1 + '\n  FROM (\n      SELECT UnPivotedColumn1\n                  ,PivotSource --Contains values PivotVal1 - X\n                  ,ColToAggregate\n      FROM TableYouWantToPivot\n  ) tbl\n  PIVOT\n  (\n  SUM(ColToAggregate)\n\n  FOR PivotSource\n  IN (\n     ' + @VB2 + '\n     )\n\n) pvt '\n\nEXEC @SQLPivot\nAnd there you have it, a Pivot statement that can pivot a table if you don’t know how many variables will be in the column you want to pivot on.\n-J"
  },
  {
    "objectID": "posts/2017-01-31-distinct-values-in-all-columns.html",
    "href": "posts/2017-01-31-distinct-values-in-all-columns.html",
    "title": "Distinct values in all columns in T-SQL",
    "section": "",
    "text": "A nifty little tool to find all the distinct values in all columns\nA few months ago I became quite frustrated because I had a huge backlog of work to do performing the Quality Control of the analyses of my team members. A large portion of performing this type of Quality Control was getting a sense of the data ingested by the analyses and determining if there were any data-specific elements of the code which were not appropriately commented or if there were strange data points in the output data. To do this I needed to quickly get a sense for the possible values in an unfamiliar table, doing the same thing over and over again gets tedious, so I wrote this little script to allow me to quickly get all the distinct values in a column for every column in a table. I’ve provided the code to do this below with explanatory comments.\n-----------------------------------------\n-- DISTINCT COLUMN QUERY\n-----------------------------------------\nDECLARE --Variable to hold our table specification\n        @tblSpec  NVARCHAR(MAX),\n        --Variable listing all unwanted columns in the table\n        @unwantedColumns NVARCHAR(MAX)\n\n\nSET @tblSpec = ''\n\n--##List any columns you don't want the distinct values from here\nSET @unwantedColumns = ''\n\n--Check if the temp table exists already, if so, boot it\nIF OBJECT_ID('tempdb..#unwantedcols') IS NOT NULL\n  DROP TABLE #unwantedcols\n\n--Create a table with all the unwanted columns to ignore\nCREATE TABLE #unwantedCols\n(colname nvarchar(max))\n\n--This is a table valued function which splits a string,\n--there are plenty of examples online for how to write one of these\nINSERT INTO #unwantedCols(colname)\nSELECT splitdata from fnSplitString(@unwantedColumns,'.')\n\n--Now is where the magic starts, we start to build our query.\n--What we are building here are a series of temporary tables\n--which split out each of the columns and counts the number\n--distinct elements in that column using the row_number()\n--function\nSELECT @tblSpec = @tblSpec+' '+\n'SELECT [' + COLUMN_NAME +']\n      , [ID] = ROW_NUMBER() OVER ( ORDER BY ['+ COLUMN_NAME+'])\nINTO [#'+COLUMN_NAME+']\nFROM [' +TABLE_NAME+']\nGROUP BY ['+COLUMN_NAME+']'\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_NAME=@tablename\nand COLUMN_NAME not in (SELECT colname from #unwantedCols)\n\n--Next we create a backbone for the distinct column table\n--which is a sequential list of numbers as long as the\n--number of rows in the table.\nSET @tblSpec += '\nSELECT\nid = ROW_NUMBER() OVER (order by newID())\nINTO #seed\nfrom ['+ @tablename+'] '\n\n--We then build a massive select statement which lists\n--all of the columns and left joins each of the\n--temporary tables created above.\n\n--To start we build the first part of the select with\n--our seed backbone column the list of numbers as\n--long as the number of rows in the table we are analysing.\nSELECT top 1\n@tblSpec = @tblSpec+' '+\n'SELECT #seed.id '\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_NAME=@tablename\nand COLUMN_NAME not in (SELECT colname from #unwantedCols)\norder by ORDINAL_POSITION asc\n\n--We then add each of the column names we want to\n--analyse to our select statement\nSELECT\n@tblSpec = @tblSpec+' '+\n',[#' +COLUMN_NAME+'].['+COLUMN_NAME+'] '\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_NAME=@tablename\nand COLUMN_NAME not in (SELECT colname from #unwantedCols)\norder by ORDINAL_POSITION asc\n\n--We start on the FROM section of the select statement\n--with our seed/backbone temp table\nSET @tblSpec += ' FROM #seed '\n\n--We then left join all of our distinct column tables\n--to the seed/backbone\nSELECT\n@tblSpec = @tblSpec+' '+\n' LEFT JOIN [#' +COLUMN_NAME+'] ON [#'+COLUMN_NAME+'].id=#seed.id '\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_NAME=@tablename\nand COLUMN_NAME not in (SELECT colname from #unwantedCols)\norder by ORDINAL_POSITION asc\n\n--Finally we make our massive select statement ordered\n--by the seed/backbone to make sure that all of our\n--distinct values are near the top\nSET @tblSpec += ' ORDER by 1'\n\n-- And finally, we execute the entire creation,\n--temp tables, seed table, and massive select statement.\nEXEC (@tblSpec)"
  },
  {
    "objectID": "posts/2012-12-10-first-or-last-in-tsql.html",
    "href": "posts/2012-12-10-first-or-last-in-tsql.html",
    "title": "First or last in T-SQL",
    "section": "",
    "text": "I’ve been looking for a while now to find a way to return just one row when the fields I am using split up my table return several rows per unique field combination. I found this little gem today:\n\nSelect\n   t1,\n   t2,\n   t3\nFrom\n(\n   Select\n      t1,\n      t2,\n      t3,\n      row_number() over (Partition by t1 order by t1) rowrank\n   from tTable\n)\nWhere rowrank &lt;=1\nThis of course does not emulate first and last exactly as it doesn’t really allow you to influence the order of the returned fields in the partitioning. It is however very useful when you just want to return one value."
  },
  {
    "objectID": "portfolio/mobile-sink-transfer-methods/mobile-sink-transfer-methods.html",
    "href": "portfolio/mobile-sink-transfer-methods/mobile-sink-transfer-methods.html",
    "title": "Sensor network transfer methods",
    "section": "",
    "text": "In the final year of my studies at the University of Oxford I joined a research group working on a sensor network. My work consisted in investigating reliable transfer methods between the nodes of the sensor network and a mobile sink which would travel through the network and gather all of the data in the network wirelessly. If you are interested in my research I have posted my thesis below."
  },
  {
    "objectID": "portfolio/mobile-sink-transfer-methods/mobile-sink-transfer-methods.html#abstract",
    "href": "portfolio/mobile-sink-transfer-methods/mobile-sink-transfer-methods.html#abstract",
    "title": "Sensor network transfer methods",
    "section": "Abstract",
    "text": "Abstract\nThis project investigates the use of mobile sinks in wireless sensor networks.It focuses on three different transfer methods - Single Acknowledgement, Double Buffered and Sliding Window. The Single Acknowledgement transfer method is a naive method which acknowledges every packet it receives. The Double Buffered method keeps the same transfer protocol but reduces transfer times by performing time intensive data preparation in advance. The Sliding Window method is a variation of the TCP cumulative acknowledgement sliding window which only uses one timer. The project also proposes a way to select with which node a mobile sink is likely to have the longest connectivity based on several RSSI values taken over a period of time. All of the methods presented in this project are designed to be integrated into the WildSensing project which focuses on monitoring badgers in the woods around Oxford.\nread more…"
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Portfolio",
    "section": "",
    "text": "Sensor network transfer methods\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSketch Shading\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-3/introduction-to-SIR-models-3.html",
    "href": "notebooks/coffee course/introduction-to-SIR-models-3/introduction-to-SIR-models-3.html",
    "title": "Python 105 - Make the SIR model more efficient and add additional parameters",
    "section": "",
    "text": "First let’s make the model more efficient. Fortunately, after exploring the functions and calculations that make up this model we can quite easily translate the calculations into a more mathematical system which computes much faster! To do this we will use a function provided by the scientific python library scipy which allows us to solve ordinary differential equations (ODEs). Don’t worry about the maths terminology, we’ve actually already done all the solveing, all we need to do is re-write our calculation method to use the more efficient library calculations.\nimport pandas as pd  # Loading the NYC dataset \nimport numpy as np   # performing fast calculations to build our simulation\nimport plotly.express as px # Quick visuals for data exploration\nfrom ipywidgets import widgets # sliders, buttons and visual layout of the dashboard\nimport plotly.graph_objects as go # plotly objects to place on our graph\nimport math # python mathematical functions\nfrom scipy.integrate import odeint\n\n# We'll set some easy defaults for this function so that we immediately have outputs which make some sense when we execute this method.\ndef calculate_values_SIR(removal_rate = .1\n                         , infection_rate = 1.1\n                         , population = 1000\n                         , days = 150\n                         , initial_infection  = 1\n                           \n                         \n                         # we've added this additional parameter which allows us to cut the \n                         # infection rate by 2 at a given day to simulate drastic policy action.\n                         , intervention_day = 50\n                         , intervention_effectiveness = .46\n                        ):\n\n    # Define a series of ordinary differential equations (math-fancy way of saying equations that model the\n    # rate of change of something) notice that all of these values are similar to the ones we were using \n    # before, we're basically going to pass everything from our current method into this method.\n    def sir(previous_day\n            , day\n            , population\n            , infection_rate\n            , removal_rate\n            , intervention_day\n            , intervention_effectiveness):\n        \n        \n        # Initialise our values like we previously did. in this Ordinary Differential Equation Solver \n        # these values will correspond to the previous day values.\n        susceptible = previous_day[0] + previous_day[3]\n        infected = previous_day[1]\n        recovered = previous_day[2]\n        \n        noi_infected = previous_day[1] + previous_day[3]\n        noi_removed = previous_day[4]\n        \n        # Like we did before, check to see if we are past the intervention day, if we are, let's reduce\n        # the infection rate by the intervention effectiveness\n        if day &gt;= intervention_day:\n            inter_infection_rate = infection_rate * max((1-intervention_effectiveness),0)\n        else:\n            inter_infection_rate = infection_rate\n        \n        # Calculate our daily changes for each of the categories:\n        \n        # susceptible\n        dsdt = -min(inter_infection_rate * infected * susceptible / population, susceptible) \n        # Infected\n        didt = (inter_infection_rate * infected * susceptible / population) - (removal_rate * infected)\n        # Removed\n        drdt = removal_rate * infected\n        \n        # If we're after the intervention day, calculate the values as if we had never made an intervention\n        if day &gt;= intervention_day:\n            \n            noi_susceptible = previous_day[0]\n            \n            noi_dsdt = (min(infection_rate * noi_infected * noi_susceptible / population, noi_susceptible))\n            noi_didt =(infection_rate * noi_infected * noi_susceptible / population) - (removal_rate * noi_infected)\n            noi_drdt = removal_rate * noi_infected\n            \n            noi_didt = noi_didt - didt\n            noi_drdt = max(noi_drdt - drdt, 0 )\n            dsdt = dsdt - noi_didt - noi_drdt\n            \n        else:\n            noi_dsdt = 0\n            noi_didt = 0\n            noi_drdt = 0\n        \n        # Return our daily change values\n        return [dsdt, didt, drdt, noi_didt, noi_drdt]\n\n    # Set the values we calculate for \n    x_days = np.rint(np.linspace(0,days,days))\n    \n    # initialize our model with the strting conditions\n    starting_condition=[population            # susceptible start\n                        , initial_infection   # infection start\n                        , 0                   # removed start\n                        , 0                   # no intevention infected start\n                        , 0]                  # no intervention removed start\n\n\n    # run a function which will simulate our equation system over a number of \n    # days with our starting positions and the the parameters we give it. \n    # this basically replaces the for loop from our previous implementation.\n    s = odeint(sir\n               , starting_condition\n               , x_days\n               , args=(population\n                       , infection_rate\n                       , removal_rate\n                       , intervention_day\n                       , intervention_effectiveness))\n\n\n    # Round our calculated values to integers and then transpose our output \n    # from a list of rows to a list of columns.\n    dat = np.rint(s).T\n    \n    # Return the desired values\n    return {'infected': dat[1]\n                , 'removed' : dat[2]\n                , 'susceptible': dat[0]\n                , 'infected_noi': dat[3]\n                , 'removed_noi': dat[4] }"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-3/introduction-to-SIR-models-3.html#display-the-new-faster-calculation-method",
    "href": "notebooks/coffee course/introduction-to-SIR-models-3/introduction-to-SIR-models-3.html#display-the-new-faster-calculation-method",
    "title": "Python 105 - Make the SIR model more efficient and add additional parameters",
    "section": "Display the new faster calculation method",
    "text": "Display the new faster calculation method\nOnce we’ve updated the calculation method, we don’t need to make any changes to the visualization code from last week, we can take it as is and plug the new calculation method in to use it.\n\n# This slider works with floating point numbers (hence being called Float Slider) and \n# allows us to set a variable with this slider. This is going to be the way we set the \n# infection rate.\nir = widgets.FloatSlider(\n                value=1.187, # this is the initial value of our slider when it appears\n                min=0.0,     # the minimum value we'll allow\n                max=5.0,     # the maximum value we'll allow\n                step=.001,   # by what increments the slider will change when we move it\n                description='Infection_rate:', # the name of the slider\n                continuous_update=True # Will this slider wait until it stops moving to \n                                        # call it's update function or does it call the \n                                        # update function immediately?\n)\n\nrr = widgets.FloatSlider(\n                value=.46,\n                min=0.1,     # this is set to greater than 0 because this is the denominator in the R0 calculation\n                max=2.0,\n                step=.01,\n                description='Removal_Rate:',\n                continuous_update=True\n)\n\n\nii = widgets.IntSlider(\n                value=1,\n                min=1,\n                max=50,\n                step=1,\n                description='Initially Infected:',\n                continuous_update=True\n)\n\nip = widgets.IntSlider(\n                value=1000,\n                min=500,\n                max=10_000_000,\n                step=500,\n                description='Initial Population:',\n                continuous_update=True\n)\n\n\niday = widgets.IntSlider(\n                value=15,\n                min=1,\n                max=150,\n                step=1,\n                description='Day of intervention (reducing infection rate):',\n                continuous_update=True\n)\n\n\nie = widgets.FloatSlider(\n                value=.46,\n                min=0.0,    \n                max=1.0,\n                step=.01,\n                description='Intervention effectiveness:',\n                continuous_update=True\n)\n\n\n\nfirst_slider_group = widgets.HBox(children=[ir, rr, ie])\nsecond_slider_group = widgets.HBox(children=[ii, ip, iday])\n\n# First, we use the method created above to calculate a model using the initial\n# values of the sliders we just created. Given that at this point we haven't \n# displayed the sliders yet, their values will be the default values we set above.\n\ndata = calculate_values_SIR(  removal_rate = rr.value\n                            , infection_rate = ir.value\n                            , population = ip.value\n                            , days = 150\n                            , initial_infection  = ii.value\n                            , intervention_day = iday.value\n                        )\n\n# Next we add all the data traces to the chart\n\ninfected_trace =  go.Bar(x = list(range(1,len(data['infected'])))\n              ,y = data['infected']\n              , name='Infected'\n              , marker = dict(color='red')\n              )\n\nsusceptible_trace = go.Bar(x = list(range(1, len(data['susceptible'])))\n              , y = data['susceptible']\n              , name='Susceptible'\n              , marker = dict(color='rgba(0,0,255,0.5)')\n              , opacity=0.5\n              )\n\nremoved_trace = go.Bar(x =list(range(1, len(data['removed'])))\n              ,y = data['removed']\n              , name='Removed'\n              , marker = dict(color='rgba(0,128,0,0.5)')\n              , opacity=0.5)\n\n\ninfected_trace_noi =  go.Bar(x = list(range(1,len(data['infected_noi'])))\n              ,y = data['infected_noi']\n              , name='Infected No Intervention'\n              , marker = dict(color='rgba(225,0,0,0.5)')\n              )\n\n\nremoved_trace_noi = go.Bar(x =list(range(1, len(data['removed_noi'])))\n              ,y = data['removed_noi']\n              , name='Removed No Intervention'\n              , marker = dict(color='rgba(0,225,0,0.5)')\n              )\n\n\n# This trace is interesting as it's basically just drawing a straight line on the \n# selected intervention day.\n\nintervention_day = go.Scatter(x = [iday.value, iday.value]\n              ,y = [0, ip.value]\n              , name='Intervention day'\n              , marker = dict(color='darkblue')\n              , line = dict(width=5)\n  )\n\n# We create our figure adding all the traces we created to the data list, and setting some layout values in the layout parameter.\ng = go.FigureWidget(data=[ infected_trace, infected_trace_noi, removed_trace, susceptible_trace, intervention_day,  removed_trace_noi ],\n                    layout=go.Layout(\n                         title={\n                                'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ir.value/ 2* rr.value} &lt;br /&gt;Infection_rate={ir.value} Removal_rate={rr.value}',\n                                'y':.95,\n                                'x':0.5,\n                                'xanchor': 'center',\n                                'yanchor': 'top'}\n                        ,barmode='stack'\n                        ,hovermode='x'\n                        ,height=900\n                        ,xaxis=dict(title='Number of Days')\n                        ,yaxis=dict(title='Number of People')\n                    ))\n\n# This is to update the x-axis range to show only the days where we have cases\ng.update_xaxes(range=[0,np.where(data['infected']==0)[0][0]])\n\nx=1\n\n# This method will be called any time one of the sliders is modified. It will re-run our model calculation\n# with the new values and update the data for the 4 traces we added to the figure. \ndef response(change):\n\n    num_days=150\n    \n    # recalculate the model using the new values defined by the sliders\n    pop_values = calculate_values_SIR(removal_rate = rr.value\n                                      , infection_rate=ir.value\n                                     , initial_infection=ii.value\n                                      , population=ip.value\n                                      , days=num_days\n                                     , intervention_day = iday.value\n                                     , intervention_effectiveness= ie.value\n                                     )\n\n    # Try to find the first day where we have no more infections, \n    # if that fails and we get an error, use the maximum number of \n    # days for which we've calculated the model. We use this later \n    # to update the x-axis range to keep our curve centered.\n    try:\n        end_infection = max( np.where(pop_values['infected_noi'][iday.value+1:]==0)[0][0] + iday.value +1,\n                             np.where(pop_values['infected']==0)[0][0] )\n    except IndexError:\n        end_infection = num_days\n    \n    # plotly updates much faster if you send all the updates in one go, \n    # this construct allows us to open an update session on our chart\n    # and when we leave it, it will send all the updates to the figure \n    # at once.\n    with g.batch_update():\n        # update the y-axis values from the model\n        g.data[0].y = pop_values['infected']\n        g.data[1].y = pop_values['infected_noi']\n        g.data[2].y = pop_values['removed']\n        g.data[3].y = pop_values['susceptible']\n        g.data[5].y = pop_values['removed_noi']\n\n        \n        # Add the intervention day line\n        g.data[4].y = [0         , ip.value]\n        g.data[4].x = [iday.value, iday.value]\n        \n        # update the title to show the R values as well as the infection rate and the removal rate\n        \n        ie_rate = ir.value * max((1-ie.value),0)\n        g.layout.title = {\n                        'text': f'R0 = {ir.value / rr.value} &lt;br /&gt; Post-Intervention R0: {ie_rate / rr.value} &lt;br /&gt; Infection_rate={ir.value} Removal_rate={rr.value}',\n                        'x':0.5,\n                        'xanchor': 'center',\n                        'yanchor': 'top'}\n        \n        # change the x-axis range to keep the infection curve in scope\n        g.layout.xaxis = dict(range=[0,end_infection])\n        \n        \n        \n        \n# Update each of the widgets and register our update method as the method to \n# call when they change.\nir.observe(response, names='value')\nrr.observe(response, names='value')\nii.observe(response, names='value')\nip.observe(response, names='value')\niday.observe(response, names='value')\nie.observe(response, names='value')\n\n# put the widgets, and our chart together into our layout\nwidgets.VBox([first_slider_group, second_slider_group, g])"
  },
  {
    "objectID": "notebooks/coffee course/introduction-to-SIR-models-3/introduction-to-SIR-models-3.html#easter-egg-can-you-find-the-bug-in-the-model-which-spawns-extra-people-can-you-explain-why-that-is-happening",
    "href": "notebooks/coffee course/introduction-to-SIR-models-3/introduction-to-SIR-models-3.html#easter-egg-can-you-find-the-bug-in-the-model-which-spawns-extra-people-can-you-explain-why-that-is-happening",
    "title": "Python 105 - Make the SIR model more efficient and add additional parameters",
    "section": "Easter Egg: Can you find the bug in the model which spawns extra people? Can you explain why that is happening?",
    "text": "Easter Egg: Can you find the bug in the model which spawns extra people? Can you explain why that is happening?"
  },
  {
    "objectID": "notebooks/coffee course/mapping-data-with-plotly/mapping-data-with-plotly.html",
    "href": "notebooks/coffee course/mapping-data-with-plotly/mapping-data-with-plotly.html",
    "title": "Python 102 - Plotting data on a map",
    "section": "",
    "text": "Before you start make sure that you have run the following commands in anaconda prompt:"
  },
  {
    "objectID": "notebooks/coffee course/mapping-data-with-plotly/mapping-data-with-plotly.html#load-the-data-set-into-a-pandas-dataframe",
    "href": "notebooks/coffee course/mapping-data-with-plotly/mapping-data-with-plotly.html#load-the-data-set-into-a-pandas-dataframe",
    "title": "Python 102 - Plotting data on a map",
    "section": "1. Load the data set into a pandas dataframe",
    "text": "1. Load the data set into a pandas dataframe\nLoad all the data into memory and see how we can combine the data into a single set for us to use with data visualization.\n\nimport glob \n# Create two lists to store our file metadata and file data\nall_data = []\nmeta_data = []\n\n# For every file in our data set path\nfor file in sorted(glob.glob(dataset_path)):\n    \n    # 1. Read the file to a temporary data frame\n    df = pd.read_csv(file)\n    \n    # 2. Append a dictionary with the file meta_data into the metadata list\n    meta_data.append( {  'file_name': file.rsplit(os.path.sep,1)[1]\n                       , 'num_rows': df.shape[0]\n                       , 'num_cols': df.shape[1]\n                       , 'col_names': '\\t'.join(sorted(list(df.columns)))} )\n    \n    # Add the file name to the loaded data\n    df['source_file'] = file\n    \n    # 4. Add the loaded data with the file name to a list with all the loaded data\n    all_data.append(df)\n\n# 5. Create a table/dataframe out of our meta_data \nmeta_data = pd.DataFrame(meta_data)\n\n# show the metadata in jupyter notebook\nmeta_data\n\n\n\n\n\n\n\n\nfile_name\nnum_rows\nnum_cols\ncol_names\n\n\n\n\n0\n01-22-2020.csv\n38\n6\nConfirmed\\tCountry/Region\\tDeaths\\tLast Update...\n\n\n1\n01-23-2020.csv\n46\n6\nConfirmed\\tCountry/Region\\tDeaths\\tLast Update...\n\n\n2\n01-24-2020.csv\n41\n6\nConfirmed\\tCountry/Region\\tDeaths\\tLast Update...\n\n\n3\n01-25-2020.csv\n44\n6\nConfirmed\\tCountry/Region\\tDeaths\\tLast Update...\n\n\n4\n01-26-2020.csv\n47\n6\nConfirmed\\tCountry/Region\\tDeaths\\tLast Update...\n\n\n...\n...\n...\n...\n...\n\n\n80\n04-11-2020.csv\n2966\n12\nActive\\tAdmin2\\tCombined_Key\\tConfirmed\\tCount...\n\n\n81\n04-12-2020.csv\n2989\n12\nActive\\tAdmin2\\tCombined_Key\\tConfirmed\\tCount...\n\n\n82\n04-13-2020.csv\n3002\n12\nActive\\tAdmin2\\tCombined_Key\\tConfirmed\\tCount...\n\n\n83\n04-14-2020.csv\n3014\n12\nActive\\tAdmin2\\tCombined_Key\\tConfirmed\\tCount...\n\n\n84\n04-15-2020.csv\n3027\n12\nActive\\tAdmin2\\tCombined_Key\\tConfirmed\\tCount...\n\n\n\n\n85 rows × 4 columns\n\n\n\n\n\npd.set_option('max_colwidth', 150)\n\n# output result to notebook window\nmeta_data.groupby(['num_cols'])\\\n         .agg({ 'num_rows': 'sum'\n              , 'file_name': sorted\n              , 'col_names': set })\n\n\n\n\n\n\n\n\nnum_rows\nfile_name\ncol_names\n\n\nnum_cols\n\n\n\n\n\n\n\n6\n2818\n[01-22-2020.csv, 01-23-2020.csv, 01-24-2020.csv, 01-25-2020.csv, 01-26-2020.csv, 01-27-2020.csv, 01-28-2020.csv, 01-29-2020.csv, 01-30-2020.csv, 0...\n{Confirmed\\tCountry/Region\\tDeaths\\tLast Update\\tProvince/State\\tRecovered}\n\n\n8\n4799\n[03-01-2020.csv, 03-02-2020.csv, 03-03-2020.csv, 03-04-2020.csv, 03-05-2020.csv, 03-06-2020.csv, 03-07-2020.csv, 03-08-2020.csv, 03-09-2020.csv, 0...\n{Confirmed\\tCountry/Region\\tDeaths\\tLast Update\\tLatitude\\tLongitude\\tProvince/State\\tRecovered}\n\n\n12\n75773\n[03-22-2020.csv, 03-23-2020.csv, 03-24-2020.csv, 03-25-2020.csv, 03-26-2020.csv, 03-27-2020.csv, 03-28-2020.csv, 03-29-2020.csv, 03-30-2020.csv, 0...\n{Active\\tAdmin2\\tCombined_Key\\tConfirmed\\tCountry_Region\\tDeaths\\tFIPS\\tLast_Update\\tLat\\tLong_\\tProvince_State\\tRecovered}\n\n\n\n\n\n\n\n\nd_data = pd.concat(all_data\n                  , axis='index'\n                  , join='outer'\n                  , ignore_index=True\n                  , sort=True)\n\nd_data.head()\n\n\n\n\n\n\n\n\nActive\nAdmin2\nCombined_Key\nConfirmed\nCountry/Region\nCountry_Region\nDeaths\nFIPS\nLast Update\nLast_Update\nLat\nLatitude\nLong_\nLongitude\nProvince/State\nProvince_State\nRecovered\nsource_file\n\n\n\n\n0\nNaN\nNaN\nNaN\n1.0\nMainland China\nNaN\nNaN\nNaN\n1/22/2020 17:00\nNaN\nNaN\nNaN\nNaN\nNaN\nAnhui\nNaN\nNaN\nus_jhu_data/csse_covid_19_data/csse_covid_19_daily_reports/01-22-2020.csv\n\n\n1\nNaN\nNaN\nNaN\n14.0\nMainland China\nNaN\nNaN\nNaN\n1/22/2020 17:00\nNaN\nNaN\nNaN\nNaN\nNaN\nBeijing\nNaN\nNaN\nus_jhu_data/csse_covid_19_data/csse_covid_19_daily_reports/01-22-2020.csv\n\n\n2\nNaN\nNaN\nNaN\n6.0\nMainland China\nNaN\nNaN\nNaN\n1/22/2020 17:00\nNaN\nNaN\nNaN\nNaN\nNaN\nChongqing\nNaN\nNaN\nus_jhu_data/csse_covid_19_data/csse_covid_19_daily_reports/01-22-2020.csv\n\n\n3\nNaN\nNaN\nNaN\n1.0\nMainland China\nNaN\nNaN\nNaN\n1/22/2020 17:00\nNaN\nNaN\nNaN\nNaN\nNaN\nFujian\nNaN\nNaN\nus_jhu_data/csse_covid_19_data/csse_covid_19_daily_reports/01-22-2020.csv\n\n\n4\nNaN\nNaN\nNaN\nNaN\nMainland China\nNaN\nNaN\nNaN\n1/22/2020 17:00\nNaN\nNaN\nNaN\nNaN\nNaN\nGansu\nNaN\nNaN\nus_jhu_data/csse_covid_19_data/csse_covid_19_daily_reports/01-22-2020.csv"
  }
]